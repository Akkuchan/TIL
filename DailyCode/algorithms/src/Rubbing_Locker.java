import java.util.*;

public class Rubbing_Locker {

//    public long ocean(int target, int[] type) {
//        // TODO:
//        // int left = target; // 큰 단위 지폐로 뺀 나머지 금액
//        if(type.isEmpty()) break;
//        List<> newtype = new ArrayList<>(Arrays.asList(type));
//        for(int j=0; j<type.length; j++){
//            for(int i=1; i<=target/type[j]; i++){//10(12345678910) -> 8  20(12345) -> 1  50(12) -> 1
//                left = target-type[j]*i// 100일 때 90부터 시작
//
//
//            }
//        }
    }

//  코드 복기(레퍼런스 코드와의 비교)
//  아래 주석을 보면 $10 지폐의 개수에 따라 나머지 지폐들의 경우의 수를 관리하려고 함
//  $10 지폐의 개수에 따라 나머지 $20, $50 지폐의 개수를 정하려 했음.
//  하지만 화폐의 개수가 무한이기에 이럴 경우 화폐 개수에 따라 내부 for문을 계속 작성해야함
//  이를 위해 재귀 함수를 사용하려함
//  하지만 코드의 구조상 선언한 원시타입의 count 값이 재귀함수 실행마다 매번 초기화 되어 누적이 안 됨.
//  그렇다면 ArrayList를 통해 count 값을 넣어주어야 겠다고 생각, 하지만 마찬가지로 재귀함수 때마다 list가 초기화됨
//  결국 type에서 첫 인데스의 값인 $10를 제외한 배열을 다시 생성해 재귀로 돌려야 하지만 재귀 마지막에 반환되는 값을 무엇으로 할지를 모르겠음.
//  왜냐면 어차피 변수++을 통한 값 누적은 불가능(재귀의 한계, 애초에 ocean 파라미터가 2개뿐이라 마지막 값으로 가져올 게 없음)
//  레퍼런스는 나의 코드와 달리 직접 선언한 단일 변수 count의 값을 반환하는 것이 아닌 target을 0~target으로 하는 가방의 경우의 수를 모두 담는 배열을 만들었음.
//  때문에 생성한 배열의 인덱스는 target을 의미하고 0부터 시작하면서 target에 따른 가방개수를 하나씩 담는다.
//  가방의 개수(target별 경우의 수)는 다음 가방의 개수를 정하는데 활용됨(beag[j] += bag[j-typ[i]];
//  결국 마지막 target(인덱스)의 값을 반환하면 끝.

// 개선할 점. 반환하는 값이 원시타입이라고 코드내에서 반드시 그 값을++ or -- 식으로 원시타입으로만 가지고 있는 것이 아닌 배열과 같은 객체의 값으로 가지고 있는 것이 더 활용도가 높다.

// bag[50]=
//10으로 10 만들기
//1   1

// type[i] <= j(10<=10)

//10, 20 가지고 20 만들기
//20 01
//
//10, 20 가지고 30만들기
//30 11
//
//10 20가지고 40만들기
//40 21 02
//
//10 20 50 가지고 50 만들기
//500 310 120 001

//10 20 50 가지고 60만들기
//600 410 210 030 101












//100달러,  90달러라면? 80
//10(12345678910) -> 8
// (0,5,0) 100
// (0,0,2) 100
// (1,2,1) 90
// (2,4,0) 80
// (3,1,1) 70
// (4,3,0) 60
// (5,0,1) 50
// (6,2,0) 40
// (8,1,0) 20
// (10,0,0)//0

// 0 2 1  80
//   1 4 0  70
//   2 1 1  60
//            ....
//   9 0 0  0
//
//   8개+ 040
//}
